{
  "file_creation": [
    {
      "pattern": "Create a file named {filename}",
      "intent_template": {
        "action": "run_code",
        "code": "open('{filename}', 'w').close()"
      },
      "variables": [
        "filename"
      ],
      "example_command": "Create a file named Cory.txt",
      "raw_command": "Create a file named Cory.txt"
    }
  ],
  "file_management": [
    {
      "pattern": "Rename all {file_extension} files in {folder_path} to follow pattern {naming_pattern}",
      "intent_template": {
        "action": "run_code",
        "code": "import os\nimport re\n\nfolder = '{folder_path}'\npattern = '{naming_pattern}'\nfile_ext = '.{file_extension}'\n\nif not os.path.exists(folder):\n    print(f\"Folder {folder} does not exist.\")\n    exit(1)\n\n# Get all files with the specified extension\nfiles = [f for f in os.listdir(folder) if f.endswith(file_ext)]\n\n# Create a regex pattern to extract parts if needed\n# Example: if naming_pattern is 'file_YYYY-MM-DD'\nfor i, filename in enumerate(files):\n    # Simple incrementing renaming as default behavior\n    new_name = pattern.replace('INDEX', str(i+1))\n    new_name = new_name.replace('ORIGINAL', os.path.splitext(filename)[0])\n    \n    # If it doesn't have the extension, add it\n    if not new_name.endswith(file_ext):\n        new_name += file_ext\n    \n    old_path = os.path.join(folder, filename)\n    new_path = os.path.join(folder, new_name)\n    \n    os.rename(old_path, new_path)\n    print(f\"Renamed: {filename} -> {new_name}\")\n\nprint(f\"Renamed {len(files)} {file_ext} files in {folder}.\")"
      },
      "variables": [
        "file_extension",
        "folder_path",
        "naming_pattern"
      ],
      "example_command": "Rename all txt files in C:\\Documents to follow pattern file_INDEX"
    },
    {
      "pattern": "Create a set of folders for {project_name} project",
      "intent_template": {
        "action": "run_code",
        "code": "import os\n\nproject_name = '{project_name}'\nbase_dir = os.getcwd()\nproject_dir = os.path.join(base_dir, project_name)\n\n# Common project structure folders\nfolders = [\n    '',  # Project root\n    'src',\n    'docs',\n    'tests',\n    'resources',\n    'config',\n    'build'\n]\n\nfor folder in folders:\n    folder_path = os.path.join(project_dir, folder)\n    if not os.path.exists(folder_path):\n        os.makedirs(folder_path)\n        print(f\"Created folder: {folder_path}\")\n    else:\n        print(f\"Folder already exists: {folder_path}\")\n\n# Create a basic README file\nreadme_path = os.path.join(project_dir, 'README.md')\nwith open(readme_path, 'w') as f:\n    f.write(f\"# {project_name}\\n\\nProject description goes here.\\n\")\n    \nprint(f\"\\nProject structure for '{project_name}' has been created successfully.\")"
      },
      "variables": [
        "project_name"
      ],
      "example_command": "Create a set of folders for MyWebApp project"
    },
    {
      "pattern": "Merge contents of all {file_extension} files in {folder_path} into a single file",
      "intent_template": {
        "action": "run_code",
        "code": "import os\nimport csv\nimport pandas as pd\n\nfolder_path = '{folder_path}'\nfile_extension = '.{file_extension}'\noutput_file = os.path.join(folder_path, f'merged{file_extension}')\n\n# Check if the folder exists\nif not os.path.exists(folder_path):\n    print(f\"Folder {folder_path} does not exist.\")\n    exit(1)\n\n# Get all files with the specified extension\nfiles = [f for f in os.listdir(folder_path) if f.endswith(file_extension)]\n\nif not files:\n    print(f\"No {file_extension} files found in {folder_path}.\")\n    exit(0)\n\nprint(f\"Found {len(files)} {file_extension} files.\")\n\n# Handle CSV files\nif file_extension.lower() == '.csv':\n    # Read all CSV files into pandas DataFrames\n    dataframes = []\n    for file in files:\n        file_path = os.path.join(folder_path, file)\n        print(f\"Reading: {file}\")\n        try:\n            df = pd.read_csv(file_path)\n            dataframes.append(df)\n        except Exception as e:\n            print(f\"Error reading {file}: {e}\")\n    \n    # Concatenate all dataframes and save to output file\n    if dataframes:\n        merged_df = pd.concat(dataframes, ignore_index=True)\n        merged_df.to_csv(output_file, index=False)\n        print(f\"\\nSuccessfully merged {len(dataframes)} files into {output_file}\")\n    else:\n        print(\"No valid CSV files to merge.\")\n\n# Handle text files\nelif file_extension.lower() in ['.txt', '.log', '.md']:\n    with open(output_file, 'w') as outfile:\n        for file in files:\n            file_path = os.path.join(folder_path, file)\n            print(f\"Appending: {file}\")\n            try:\n                with open(file_path, 'r') as infile:\n                    outfile.write(f\"\\n--- Content from {file} ---\\n\\n\")\n                    outfile.write(infile.read())\n                    outfile.write(\"\\n\\n\")\n            except Exception as e:\n                print(f\"Error reading {file}: {e}\")\n    \n    print(f\"\\nSuccessfully merged {len(files)} files into {output_file}\")\n\nelse:\n    print(f\"Merging {file_extension} files is not supported.\")"
      },
      "variables": [
        "file_extension",
        "folder_path"
      ],
      "example_command": "Merge contents of all csv files in C:\\Data\\Reports into a single file"
    },
    {
      "pattern": "Search for and delete all {file_pattern} files in {folder_path}",
      "intent_template": {
        "action": "run_code",
        "code": "import os\nimport glob\n\nfolder_path = '{folder_path}'\nfile_pattern = '{file_pattern}'\n\n# Check if the folder exists\nif not os.path.exists(folder_path):\n    print(f\"Folder {folder_path} does not exist.\")\n    exit(1)\n\n# Get the search pattern\nsearch_pattern = os.path.join(folder_path, file_pattern)\nprint(f\"Searching for: {search_pattern}\")\n\n# Find all matching files\nmatching_files = glob.glob(search_pattern, recursive=True)\n\nif not matching_files:\n    print(f\"No files matching '{file_pattern}' found in {folder_path}.\")\n    exit(0)\n\nprint(f\"Found {len(matching_files)} matching files:\")\nfor file in matching_files[:5]:  # Show first 5 files\n    print(f\"- {os.path.basename(file)}\")\n\nif len(matching_files) > 5:\n    print(f\"... and {len(matching_files) - 5} more\")\n\n# Confirm deletion\nconfirm = input(f\"\\nDelete {len(matching_files)} files? (yes/no): \")\nif confirm.lower() not in ['yes', 'y']:\n    print(\"Operation cancelled.\")\n    exit(0)\n\n# Delete the files\ndeleted_count = 0\nfor file in matching_files:\n    try:\n        os.remove(file)\n        deleted_count += 1\n    except Exception as e:\n        print(f\"Error deleting {file}: {e}\")\n\nprint(f\"\\nSuccessfully deleted {deleted_count} files.\")"
      },
      "variables": [
        "file_pattern",
        "folder_path"
      ],
      "example_command": "Search for and delete all *.tmp files in C:\\Temp"
    },
    {
      "pattern": "Copy recently edited files from {source_dir} to {backup_dir} modified in the last {days} days",
      "intent_template": {
        "action": "run_code",
        "code": "import os\nimport shutil\nimport time\nfrom datetime import datetime, timedelta\n\nsource_dir = '{source_dir}'\nbackup_dir = '{backup_dir}'\ndays = int('{days}')\n\n# Check if the source directory exists\nif not os.path.exists(source_dir):\n    print(f\"Source directory {source_dir} does not exist.\")\n    exit(1)\n\n# Create backup directory if it doesn't exist\nif not os.path.exists(backup_dir):\n    os.makedirs(backup_dir)\n    print(f\"Created backup directory: {backup_dir}\")\n\n# Calculate the cutoff time (now - days)\ncutoff_time = time.time() - (days * 24 * 60 * 60)\n\n# Find and copy recently modified files\ncopied_count = 0\nprint(f\"Copying files modified in the last {days} days:\")\n\nfor root, _, files in os.walk(source_dir):\n    for file in files:\n        file_path = os.path.join(root, file)\n        \n        # Get file modification time\n        mod_time = os.path.getmtime(file_path)\n        \n        # Check if file was modified after the cutoff time\n        if mod_time > cutoff_time:\n            # Create relative path to maintain directory structure\n            rel_path = os.path.relpath(file_path, source_dir)\n            backup_path = os.path.join(backup_dir, rel_path)\n            \n            # Create directories if they don't exist\n            os.makedirs(os.path.dirname(backup_path), exist_ok=True)\n            \n            # Copy the file\n            try:\n                shutil.copy2(file_path, backup_path)\n                copied_count += 1\n                mod_date = datetime.fromtimestamp(mod_time).strftime('%Y-%m-%d %H:%M')\n                print(f\"- {rel_path} (Last modified: {mod_date})\")\n            except Exception as e:\n                print(f\"Error copying {file_path}: {e}\")\n\nprint(f\"\\nSuccessfully copied {copied_count} recently modified files to {backup_dir}.\")"
      },
      "variables": [
        "source_dir",
        "backup_dir",
        "days"
      ],
      "example_command": "Copy recently edited files from C:\\Projects to C:\\Backup modified in the last 7 days"
    }
  ],
  "open_webpage": [
    {
      "pattern": "Generate Python code using Selenium that:- Opens Chrome- Goes to {url}- Waits for page load- Types \"Hello world from my assistant\" in the post composer- Clicks the Tweet buttonAssume the user is already logged in. No markdown. Output as:{ \"action\": \"run_code\", \"code\": \"<python code>\" }.",
      "intent_template": {
        "action": "run_code",
        "code": "from selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\n\ndriver = webdriver.Chrome(executable_path='chromedriver.exe')\ntry:\n    driver.get('{url}')\n    wait = WebDriverWait(driver, 10)\n    tweet_button = wait.until(EC.presence_of_element_located((By.ID, 'tweetButtonInline')))\n    post_composer = driver.find_element(By.ID, 'react-root')\n    post_composer.send_keys('Hello world from my assistant')\n    tweet_button.click()\n    sleep(5)\nfinally:\n    driver.close()"
      },
      "variables": [
        "url"
      ],
      "example_command": "Generate Python code using Selenium that:- Opens Chrome- Goes to https://x.com- Waits for page load- Types \"Hello world from my assistant\" in the post composer- Clicks the Tweet buttonAssume the user is already logged in. No markdown. Output as:{ \"action\": \"run_code\", \"code\": \"<python code>\" }.",
      "raw_command": "Generate Python code using Selenium that:- Opens Chrome- Goes to https://x.com- Waits for page load- Types \"Hello world from my assistant\" in the post composer- Clicks the Tweet buttonAssume the user is already logged in. No markdown. Output as:{ \"action\": \"run_code\", \"code\": \"<python code>\" }."
    }
  ],
  "custom_command": [
    {
      "pattern": "create {number} files named 1 through {number}",
      "intent_template": {
        "action": "run_code",
        "code": "for i in range(1, 11):\n    open(str(i) + '.txt', 'w').close()"
      },
      "variables": [
        "number"
      ],
      "example_command": "create 10 files named 1 through 10",
      "raw_command": "create 10 files named 1 through 10"
    }
  ]
}